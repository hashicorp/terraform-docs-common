---
page_title: Dynamic Credentials with the Kubernetes and Helm Provider - Workspaces - Terraform Cloud
description: >-
  Use OpenID Connect to get short-term credentials for the Kubernetes and Helm Terraform providers in
  your Terraform Cloud runs.
---

# Dynamic Credentials with the Kubernetes and Helm providers

~> **Important:** If you are self-hosting [Terraform Cloud Agents](/terraform/cloud-docs/agents), ensure your agents use [v1.14.0](/terraform/cloud-docs/agents/changelog#1-7-0-03-02-2023) or above. To use the latest dynamic credentials features, [upgrade your agents to the latest version](/terraform/cloud-docs/agents/changelog).

You can use Terraform Cloud’s native OpenID Connect integration with Kubernetes to get [dynamic credentials](/terraform/cloud-docs/workspaces/dynamic-provider-credentials) for the Kubernetes and Helm providers in your Terraform Cloud runs. Configuring the integration requires the following steps:

1. **[Configure Kubernetes](#configure-kubernetes):** Set up a trust configuration between Kubernetes and Terraform Cloud. Then, you must create Kubernetes role bindings for your Terraform Cloud identities.
2. **[Configure Terraform Cloud](#configure-terraform-cloud):** Add environment variables to the Terraform Cloud workspaces where you want to use Dynamic Credentials.
3. **[Configure the Kubernetes or Helm provider](#configure-the-provider)** Set the required attributes on the provider block.

Once you complete the setup, Terraform Cloud automatically authenticates to Kubernetes during each run. The Kubernetes and Helm providers' authentication is valid for the length of the plan or apply.

## Configure Kubernetes

You must enable and configure an OIDC identity provider in the Kubernetes API. The workflow to do this depend on the platform that is hosting your Kubernetes cluster. Dynamic provider credentials with Kubernetes is only supported in AWS and GCP.

### Configure an OIDC Identity Provider

AWS documentation describes setting up an EKS cluster for OIDC authentication here: [Authenticating users for your cluster from an OpenID Connect identity provider](https://docs.aws.amazon.com/eks/latest/userguide/authenticate-oidc-identity-provider.html). Refer to our [example Terraform configuration](https://github.com/hashicorp-education/learn-terraform-dynamic-credentials/tree/main/eks/trust).

GCP documentation describes setting up a GKE cluster for OIDC authentication here: [Use external identity providers to authenticate to GKE](https://cloud.google.com/kubernetes-engine/docs/how-to/oidc). Refer to our [example Terraform configuration](https://github.com/hashicorp-education/learn-terraform-dynamic-credentials/tree/main/gke/trust).

The value for "issuer URL" should be set to the address of Terraform Cloud (e.g., https://app.terraform.io **without** a trailing slash) or the URL of your Terraform Enterprise instance. The value for "client ID" is your audience in OIDC terminology and it should match the value of the `TFC_KUBERNETES_WORKLOAD_IDENTITY_AUDIENCE` environment variable in your workspace.

The OIDC identity will resolve authentication to the Kubernetes API, but it requires authorization in order to interact with the Kubernetes API. You must bind RBAC roles to the OIDC identity in Kubernetes. You can use both "User" and "Group" subjects in your role bindings. For OIDC identities coming from TFC, the User value will have a format of `organization:<MY-ORG-NAME>:project:<MY-PROJECT-NAME>:workspace:<MY-WORKSPACE-NAME>:run_phase:<plan|apply>`. The Group value is extracted form the token claim configured for this purpose in your cluster OIDC configuration. The complete structure of the TFC token is described here: [Workload Identity](/terraform/cloud-docs/workspaces/dynamic-provider-credentials/workload-identity-tokens)

A `RoleBinding` for the Terraform Cloud OIDC identity will looks like this:

```hcl
resource "kubernetes_cluster_role_binding_v1" "oidc_role" {
  metadata {
    name = "odic-identity"
  }

  role_ref {
    api_group = "rbac.authorization.k8s.io"
    kind      = "ClusterRole"
    name      = var.rbac_group_cluster_role
  }

  // Option A - Bind RBAC roles to groups
  //
  // Groups are extracted from the token claim designated by 'rbac_group_oidc_claim'
  //
  subject {
    api_group = "rbac.authorization.k8s.io"
    kind      = "Group"
    name      = var.tfc_organization_name
  }

  // Option B - Bind RBAC roles to user indentities
  //
  // Users are extracted from the 'sub' token claim.
  // Plan and apply phases get assigned different users identities.
  // For TFC tokens, the format of the user id is always the one described bellow.
  //
  subject {
    api_group = "rbac.authorization.k8s.io"
    kind      = "User"
    name      = "organization:${var.tfc_organization_name}:project:${var.tfc_project_name}:workspace:${var.tfc_workspace_name}:run_phase:plan"
  }

  subject {
    api_group = "rbac.authorization.k8s.io"
    kind      = "User"
    name      = "organization:${var.tfc_organization_name}:project:${var.tfc_project_name}:workspace:${var.tfc_workspace_name}:run_phase:apply"
  }
}
```

When using User subjects for the binding, be aware that Plan and Apply phases get assigned different identities and they each need specific bindings. This way you can tailor the permissions for each phase. Plans usually only requires read-only permissions while applies also requires write access.

!> **Warning**: you should always check, at minimum, the audience and the name of the organization in order to prevent unauthorized access from other Terraform Cloud organizations!

## Configure Terraform Cloud

You’ll need to set some environment variables in your Terraform Cloud workspace in order to configure Terraform Cloud to authenticate with AWS using dynamic credentials. You can set these as workspace variables, or if you’d like to share one AWS role across multiple workspaces, you can use a variable set.

### Required Environment Variables
| Variable                | Value                                 | Notes                                                                                                                                                                                                                                                                                           |
|-------------------------|---------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| TFC_KUBERNETES_PROVIDER_AUTH | `true` | Requires **v1.14.0** or later if self-managing agents. Must be present and set to `true`, or Terraform Cloud will not attempt to authenticate to Kubernetes. |
| TFC_KUBERNETES_WORKLOAD_IDENTITY_AUDIENCE | The audience name in your cluster's OIDC configuration, such as `kubernetes`. | Requires **v1.14.0** or later if self-managing agents. |

## Configure the provider

The Kubernetes and Helm providers share the same schema of configuration attributes for the provider block. The example below illustrates using the Kubernetes provider but the same configuration applies to the Helm provider.

Make sure that you are not using any of the other arguments or methods listed in the [authentication](https://registry.terraform.io/providers/hashicorp/kubernetes/latest/docs#authentication) section of the provider documentation as these settings may interfere with dynamic provider credentials. The only allowed provider attributes `host` and `cluster_ca_certificate`.

### Single provider instance

Terraform Cloud will automatically set the `KUBE_TOKEN` environment variable and include the workload identity token.

The provider needs to be configured with the URL of the API endpoint using the `host` attribute (or `KUBE_HOST` environment variable). In most cases, the `cluster_ca_certificate` (or `KUBE_CLUSTER_CA_CERT_DATA` environment variable) is also required.

#### Example Usage

```hcl
provider "kubernetes" {
  host                   = var.cluster-endpoint-url
  cluster_ca_certificate = base64decode(var.cluster-endpoint-ca)
}
```

### Multiple aliases

You can add additional configurations to handle multiple distinct Kubernetes clusters, enabling you to use multiple [provider aliases](/terraform/language/providers/configuration#alias-multiple-provider-configurations) within the same workspace.

For more details, see [Specifying Multiple Configurations](/terraform/cloud-docs/workspaces/dynamic-provider-credentials/specifying-multiple-configurations).

#### Required Terraform Variable

To use additional configurations, add the following code to your Terraform configuration. This lets Terraform Cloud supply variable values that you can then use to map authentication and configuration details to the correct provider blocks.

```hcl
variable "tfc_kubernetes_dynamic_credentials" {
  description = "Object containing Kubernetes dynamic credentials configuration"
  type = object({
    default = object({
      token_path = string
    })
    aliases = map(object({
      token_path = string
    }))
  })
}
```

#### Example Usage

```hcl
provider "kubernetes" {
  alias                  = "ALIAS1"
  host                   = var.alias1-endpoint-url
  cluster_ca_certificate = base64decode(var.alias1-cluster-ca)
  token                  = file(var.tfc_kubernetes_dynamic_credentials.aliases["ALIAS1"].token_path)
}

provider "kubernetes" {
  alias                  = "ALIAS2"
  host                   = var.alias1-endpoint-url
  cluster_ca_certificate = base64decode(var.alias1-cluster-ca)
  token                  = file(var.tfc_kubernetes_dynamic_credentials.aliases["ALIAS2"].token_path)
}
```

The `tfc_kubernetes_dynamic_credentials` variable is also available to use for single provider configurations, instead of the `KUBE_TOKEN` environment variable.

```hcl
provider "kubernetes" {
  host                   = var.cluster-endpoint-url
  cluster_ca_certificate = base64decode(var.cluster-endpoint-ca)
  token                  = file(var.tfc_kubernetes_dynamic_credentials.default.token_path)
}
```